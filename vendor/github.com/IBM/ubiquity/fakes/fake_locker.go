/**
 * Copyright 2017 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/IBM/ubiquity/utils"
)

type FakeLocker struct {
	WriteLockStub        func(name string)
	writeLockMutex       sync.RWMutex
	writeLockArgsForCall []struct {
		name string
	}
	WriteUnlockStub        func(name string)
	writeUnlockMutex       sync.RWMutex
	writeUnlockArgsForCall []struct {
		name string
	}
	ReadLockStub        func(name string)
	readLockMutex       sync.RWMutex
	readLockArgsForCall []struct {
		name string
	}
	ReadUnlockStub        func(name string)
	readUnlockMutex       sync.RWMutex
	readUnlockArgsForCall []struct {
		name string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLocker) WriteLock(name string) {
	fake.writeLockMutex.Lock()
	fake.writeLockArgsForCall = append(fake.writeLockArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("WriteLock", []interface{}{name})
	fake.writeLockMutex.Unlock()
	if fake.WriteLockStub != nil {
		fake.WriteLockStub(name)
	}
}

func (fake *FakeLocker) WriteLockCallCount() int {
	fake.writeLockMutex.RLock()
	defer fake.writeLockMutex.RUnlock()
	return len(fake.writeLockArgsForCall)
}

func (fake *FakeLocker) WriteLockArgsForCall(i int) string {
	fake.writeLockMutex.RLock()
	defer fake.writeLockMutex.RUnlock()
	return fake.writeLockArgsForCall[i].name
}

func (fake *FakeLocker) WriteUnlock(name string) {
	fake.writeUnlockMutex.Lock()
	fake.writeUnlockArgsForCall = append(fake.writeUnlockArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("WriteUnlock", []interface{}{name})
	fake.writeUnlockMutex.Unlock()
	if fake.WriteUnlockStub != nil {
		fake.WriteUnlockStub(name)
	}
}

func (fake *FakeLocker) WriteUnlockCallCount() int {
	fake.writeUnlockMutex.RLock()
	defer fake.writeUnlockMutex.RUnlock()
	return len(fake.writeUnlockArgsForCall)
}

func (fake *FakeLocker) WriteUnlockArgsForCall(i int) string {
	fake.writeUnlockMutex.RLock()
	defer fake.writeUnlockMutex.RUnlock()
	return fake.writeUnlockArgsForCall[i].name
}

func (fake *FakeLocker) ReadLock(name string) {
	fake.readLockMutex.Lock()
	fake.readLockArgsForCall = append(fake.readLockArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("ReadLock", []interface{}{name})
	fake.readLockMutex.Unlock()
	if fake.ReadLockStub != nil {
		fake.ReadLockStub(name)
	}
}

func (fake *FakeLocker) ReadLockCallCount() int {
	fake.readLockMutex.RLock()
	defer fake.readLockMutex.RUnlock()
	return len(fake.readLockArgsForCall)
}

func (fake *FakeLocker) ReadLockArgsForCall(i int) string {
	fake.readLockMutex.RLock()
	defer fake.readLockMutex.RUnlock()
	return fake.readLockArgsForCall[i].name
}

func (fake *FakeLocker) ReadUnlock(name string) {
	fake.readUnlockMutex.Lock()
	fake.readUnlockArgsForCall = append(fake.readUnlockArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("ReadUnlock", []interface{}{name})
	fake.readUnlockMutex.Unlock()
	if fake.ReadUnlockStub != nil {
		fake.ReadUnlockStub(name)
	}
}

func (fake *FakeLocker) ReadUnlockCallCount() int {
	fake.readUnlockMutex.RLock()
	defer fake.readUnlockMutex.RUnlock()
	return len(fake.readUnlockArgsForCall)
}

func (fake *FakeLocker) ReadUnlockArgsForCall(i int) string {
	fake.readUnlockMutex.RLock()
	defer fake.readUnlockMutex.RUnlock()
	return fake.readUnlockArgsForCall[i].name
}

func (fake *FakeLocker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.writeLockMutex.RLock()
	defer fake.writeLockMutex.RUnlock()
	fake.writeUnlockMutex.RLock()
	defer fake.writeUnlockMutex.RUnlock()
	fake.readLockMutex.RLock()
	defer fake.readLockMutex.RUnlock()
	fake.readUnlockMutex.RLock()
	defer fake.readUnlockMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeLocker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ utils.Locker = new(FakeLocker)
